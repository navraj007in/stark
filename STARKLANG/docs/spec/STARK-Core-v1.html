<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>STARK-Core-v1</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="stark-core-language-specification-overview">STARK Core Language
Specification Overview</h1>
<h2 id="introduction">Introduction</h2>
<p>This document provides an overview of the complete STARK core
language specification. The documents in <code>docs/spec/</code> are
normative for Core v1. The core language defines the general-purpose
language surface (lexing, syntax, types, semantics, memory, modules, and
standard library). Non-core extensions are defined separately.</p>
<h2 id="design-philosophy">Design Philosophy</h2>
<h3 id="core-principles">Core Principles</h3>
<ol type="1">
<li><strong>Memory Safety</strong>: Prevent common memory errors through
ownership and borrowing</li>
<li><strong>Performance</strong>: Zero-cost abstractions and predictable
execution</li>
<li><strong>Clarity</strong>: Simple, explicit syntax and semantics</li>
<li><strong>Pragmatism</strong>: A minimal, implementable Core v1</li>
<li><strong>Interoperability</strong>: Clear boundaries for future
extensions</li>
</ol>
<h3 id="language-goals">Language Goals</h3>
<ul>
<li>A safe, compiled, general-purpose language core</li>
<li>Compile-time guarantees for memory and type safety</li>
<li>Simple, predictable semantics suitable for tooling</li>
<li>Clear extension points for domain-specific features</li>
</ul>
<h2 id="specification-structure">Specification Structure</h2>
<h3 id="lexical-grammar-01-lexical-grammar.md">1. Lexical Grammar (<a
href="./01-Lexical-Grammar.md">01-Lexical-Grammar.md</a>)</h3>
<p>Defines how source code is tokenized: - <strong>Keywords</strong>:
Control flow, declarations, types, operators -
<strong>Identifiers</strong>: Variables, functions, types
(snake_case/PascalCase) - <strong>Literals</strong>: Integers, floats,
strings, characters, booleans - <strong>Operators</strong>: Arithmetic,
comparison, logical, bitwise, assignment - <strong>Comments</strong>:
Single-line (<code>//</code>) and multi-line (<code>/* */</code>) -
<strong>Whitespace</strong>: Space, tab, newline handling</p>
<h3 id="syntax-grammar-02-syntax-grammar.md">2. Syntax Grammar (<a
href="./02-Syntax-Grammar.md">02-Syntax-Grammar.md</a>)</h3>
<p>Defines the concrete syntax using EBNF: - <strong>Program
Structure</strong>: Items (functions, structs, enums, traits) -
<strong>Expressions</strong>: Precedence, associativity -
<strong>Statements</strong>: Variable declarations, control flow,
returns - <strong>Type Syntax</strong>: Primitives, composites,
references, functions - <strong>Pattern Matching</strong>: Destructuring
and exhaustiveness</p>
<h3 id="type-system-03-type-system.md">3. Type System (<a
href="./03-Type-System.md">03-Type-System.md</a>)</h3>
<p>Comprehensive type system with safety guarantees: - <strong>Primitive
Types</strong>: Integers, floats, booleans, characters, strings -
<strong>Composite Types</strong>: Arrays, tuples, structs, enums -
<strong>Reference Types</strong>: Immutable and mutable references -
<strong>Ownership Model</strong>: Move semantics, borrowing rules -
<strong>Type Inference</strong>: Local and function return type
inference - <strong>Trait System</strong>: Interfaces and generic
constraints</p>
<h3 id="semantic-analysis-04-semantic-analysis.md">4. Semantic Analysis
(<a href="./04-Semantic-Analysis.md">04-Semantic-Analysis.md</a>)</h3>
<p>Rules for meaningful program validation: - <strong>Symbol
Resolution</strong>: Scoping, shadowing, name lookup - <strong>Type
Checking</strong>: Assignment compatibility, function calls -
<strong>Ownership Analysis</strong>: Move tracking, borrow checking -
<strong>Control Flow</strong>: Reachability, return path analysis -
<strong>Pattern Exhaustiveness</strong>: Match completeness checking -
<strong>Error Reporting</strong>: Comprehensive diagnostics with
suggestions</p>
<h3 id="memory-model-05-memory-model.md">5. Memory Model (<a
href="./05-Memory-Model.md">05-Memory-Model.md</a>)</h3>
<p>Memory safety through compile-time analysis: - <strong>Ownership
Rules</strong>: Single ownership, automatic cleanup - <strong>Move
Semantics</strong>: Explicit ownership transfer - <strong>Borrowing
System</strong>: Immutable and mutable references - <strong>Lifetime
Tracking</strong>: Reference validity guarantees - <strong>Stack vs
Heap</strong>: Allocation strategy and layout - <strong>Drop
System</strong>: Automatic and manual resource cleanup</p>
<h3 id="standard-library-06-standard-library.md">6. Standard Library (<a
href="./06-Standard-Library.md">06-Standard-Library.md</a>)</h3>
<p>Essential types and functions for practical programming: -
<strong>Core Types</strong>: Option, Result, Box, Vec, HashMap -
<strong>String Handling</strong>: Unicode-aware string operations -
<strong>Collections</strong>: Dynamic arrays, hash tables, sets -
<strong>IO Operations</strong>: File handling, console output -
<strong>Math Functions</strong>: Arithmetic, trigonometric, random
numbers - <strong>Error Handling</strong>: Structured error types and
propagation</p>
<h3 id="modules-and-packages-07-modules-and-packages.md">7. Modules and
Packages (<a
href="./07-Modules-and-Packages.md">07-Modules-and-Packages.md</a>)</h3>
<p>Defines module structure, visibility, and import resolution: -
<strong>Modules</strong>: File and directory layout -
<strong>Visibility</strong>: <code>pub</code>/<code>priv</code> rules -
<strong>Imports</strong>: <code>use</code> paths, trees, and aliasing -
<strong>Packages</strong>: Manifest and dependency resolution</p>
<h3 id="non-core-extensions-..extensionsai-extensions.md">8. Non-Core
Extensions (../extensions/AI-Extensions.md)</h3>
<p>Non-core language extensions live outside Core v1 and are optional.
See <code>docs/extensions/AI-Extensions.md</code>.</p>
<h2 id="core-language-features">Core Language Features</h2>
<h3 id="variables-and-mutability">Variables and Mutability</h3>
<pre class="stark"><code>let x = 42              // Immutable by default
let mut y = 10          // Explicitly mutable
const MAX_SIZE: Int32 = 1000  // Compile-time constant</code></pre>
<h3 id="functions">Functions</h3>
<pre class="stark"><code>fn add(a: Int32, b: Int32) -&gt; Int32 {
    a + b
}

fn greet(name: &amp;str) {
    println(&quot;Hello, &quot; + name)
}</code></pre>
<h3 id="ownership-and-borrowing">Ownership and Borrowing</h3>
<pre class="stark"><code>fn consume(s: String) {
    // s is owned here
}

fn borrow(s: &amp;String) -&gt; Int32 {
    s.len()
}

fn mutate(s: &amp;mut String) {
    s.push(&#39;!&#39;)
}</code></pre>
<h2 id="implementation-phases">Implementation Phases</h2>
<h3 id="phase-1-core-mvp">Phase 1: Core MVP</h3>
<p><strong>Goal</strong>: A complete, implementable Core v1 - Lexer and
parser for core syntax - Type checker with ownership analysis - Module
system and import resolution - Minimal standard library</p>
<h3 id="phase-2-tooling-and-stability">Phase 2: Tooling and
Stability</h3>
<p><strong>Goal</strong>: A stable core suitable for real use - Improved
diagnostics and error recovery - Formatter and basic tooling support -
Expanded standard library coverage</p>
<h2 id="success-criteria">Success Criteria</h2>
<h3 id="correctness">Correctness</h3>
<ul class="task-list">
<li><label><input type="checkbox" />Memory safety enforced by ownership
and borrowing</label></li>
<li><label><input type="checkbox" />Deterministic type checking and
inference</label></li>
<li><label><input type="checkbox" />Exhaustive match
checking</label></li>
</ul>
<h3 id="developer-experience">Developer Experience</h3>
<ul class="task-list">
<li><label><input type="checkbox" />Clear, actionable error
messages</label></li>
<li><label><input type="checkbox" />Predictable module and import
rules</label></li>
<li><label><input type="checkbox" />Stable core language
surface</label></li>
</ul>
<h2 id="next-steps">Next Steps</h2>
<ol type="1">
<li><strong>Finalize Core Grammar</strong>: Resolve remaining
ambiguities in syntax and lexing</li>
<li><strong>Solidify Type Rules</strong>: Confirm inference and trait
constraints</li>
<li><strong>Define Module Rules</strong>: Ensure deterministic
resolution and visibility</li>
<li><strong>Validate Stdlib Surface</strong>: Confirm minimal APIs and
behaviors</li>
</ol>
<p>This specification provides a focused foundation for implementing a
safe, performant, general-purpose language core.</p>
<h2 id="conformance">Conformance</h2>
<p>A conforming Core v1 implementation MUST follow the requirements in
this document. Any deviations or extensions MUST be explicitly
documented by the implementation.</p>
<hr />
<h1 id="stark-lexical-grammar-specification">STARK Lexical Grammar
Specification</h1>
<h2 id="overview">Overview</h2>
<p>This document defines the lexical structure of STARK - how source
code is broken down into tokens.</p>
<h2 id="token-categories">Token Categories</h2>
<h3 id="keywords">1. Keywords</h3>
<pre><code>// Control Flow
if, else, match
for, while, loop, break, continue, return

// Declarations
fn, struct, enum, trait, impl, let, mut, const, type, use, mod

// Types
Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64
Float32, Float64, Bool, String, Char, Unit, str

// Visibility
pub, priv

// Module Paths
self, super, crate

// Operators
and, or, not, in, is, as

// Literals
true, false</code></pre>
<h3 id="identifiers">2. Identifiers</h3>
<pre><code>IDENTIFIER := [a-zA-Z_][a-zA-Z0-9_]*</code></pre>
<p>Rules: - Must start with letter or underscore - Can contain letters,
digits, underscores - Case sensitive - Cannot be keywords - Maximum
length: 255 characters</p>
<h3 id="literals">3. Literals</h3>
<h4 id="integer-literals">Integer Literals</h4>
<pre><code>DECIMAL_INT := [0-9][0-9_]*
HEX_INT     := 0[xX][0-9a-fA-F][0-9a-fA-F_]*
BINARY_INT  := 0[bB][01][01_]*
OCTAL_INT   := 0[oO][0-7][0-7_]*

// Type suffixes
INT_SUFFIX := (i8|i16|i32|i64|u8|u16|u32|u64)</code></pre>
<p>Examples:</p>
<pre class="stark"><code>42
1_000_000
0xFF_FF
0b1010_1010
0o755
42i32
255u8</code></pre>
<h4 id="floating-point-literals">Floating Point Literals</h4>
<pre><code>FLOAT := DECIMAL_INT &#39;.&#39; [0-9][0-9_]* [EXPONENT]?
       | DECIMAL_INT EXPONENT
EXPONENT := [eE][+-]?[0-9][0-9_]*

// Type suffixes
FLOAT_SUFFIX := (f32|f64)</code></pre>
<p>Examples:</p>
<pre class="stark"><code>3.14
1.0e10
2.5e-3
42.0f32</code></pre>
<h4 id="string-literals">String Literals</h4>
<pre><code>STRING := &#39;&quot;&#39; (CHAR | ESCAPE_SEQUENCE)* &#39;&quot;&#39;
RAW_STRING := &#39;r&quot;&#39; .*? &#39;&quot;&#39;

ESCAPE_SEQUENCE := &#39;\&#39; (n|t|r|0|\\|&#39;|&quot;|x[0-9a-fA-F]{2}|u{[0-9a-fA-F]{1,6}})</code></pre>
<p>Examples:</p>
<pre class="stark"><code>&quot;Hello, World!&quot;
&quot;Line 1\nLine 2&quot;
&quot;\x41\x42\x43&quot;
&quot;\u{1F600}&quot;
r&quot;Raw string with \n literal backslashes&quot;</code></pre>
<h4 id="character-literals">Character Literals</h4>
<pre><code>CHAR := &#39;\&#39;&#39; (CHAR_CONTENT | ESCAPE_SEQUENCE) &#39;\&#39;&#39;
CHAR_CONTENT := [^&#39;\\]</code></pre>
<p>Examples:</p>
<pre class="stark"><code>&#39;a&#39;
&#39;\n&#39;
&#39;\x41&#39;
&#39;\u{1F600}&#39;</code></pre>
<h4 id="boolean-literals">Boolean Literals</h4>
<pre><code>BOOL := true | false</code></pre>
<h3 id="operators">4. Operators</h3>
<h4 id="arithmetic">Arithmetic</h4>
<pre><code>+ - * / % **</code></pre>
<h4 id="comparison">Comparison</h4>
<pre><code>== != &lt; &lt;= &gt; &gt;=</code></pre>
<h4 id="logical">Logical</h4>
<pre><code>&amp;&amp; || !</code></pre>
<h4 id="bitwise">Bitwise</h4>
<pre><code>&amp; | ^ ~ &lt;&lt; &gt;&gt;</code></pre>
<h4 id="assignment">Assignment</h4>
<pre><code>= += -= *= /= %= **= &amp;= |= ^= &lt;&lt;= &gt;&gt;=</code></pre>
<h4 id="other">Other</h4>
<pre><code>? : :: . -&gt; =&gt; @ # $</code></pre>
<h3 id="delimiters">5. Delimiters</h3>
<pre><code>( ) [ ] { } , ; :</code></pre>
<h3 id="comments">6. Comments</h3>
<pre><code>// Single line comment
/* Multi-line comment */
/** Documentation comment */</code></pre>
<p>Rules: - Single line comments start with <code>//</code> and continue
to end of line - Multi-line comments start with <code>/*</code> and end
with <code>*/</code> - Multi-line comments can be nested - Documentation
comments start with <code>/**</code> and are associated with following
declaration</p>
<h3 id="whitespace">7. Whitespace</h3>
<ul>
<li>Space (U+0020)</li>
<li>Tab (U+0009)</li>
<li>Newline (U+000A)</li>
<li>Carriage Return (U+000D)</li>
</ul>
<p>Whitespace separates tokens and is otherwise ignored. Statement
termination is defined by semicolons in the syntax grammar.</p>
<h3 id="token-precedence">8. Token Precedence</h3>
<p>When multiple token patterns could match: 1. Keywords take precedence
over identifiers 2. Longer operators take precedence over shorter ones
3. Comments are ignored in token stream</p>
<h3 id="reserved-tokens">9. Reserved Tokens</h3>
<p>Reserved for future use:</p>
<pre><code>async, await, yield, where, macro, unsafe, extern, import, export, null</code></pre>
<h2 id="lexical-analysis-rules">Lexical Analysis Rules</h2>
<ol type="1">
<li><strong>Maximal Munch</strong>: Always match the longest possible
token</li>
<li><strong>Whitespace</strong>: Ignored except for token
separation</li>
<li><strong>Encoding</strong>: Source files must be valid UTF-8</li>
</ol>
<h2 id="error-handling">Error Handling</h2>
<p>Invalid tokens should produce specific error messages: - Invalid
character: “Unexpected character ‘X’ at line Y:Z” - Unterminated string:
“Unterminated string literal at line Y:Z” - Invalid number: “Invalid
number format at line Y:Z” ## Conformance A conforming Core v1
implementation MUST follow the requirements in this document. Any
deviations or extensions MUST be explicitly documented by the
implementation.</p>
<hr />
<h1 id="stark-syntax-grammar-specification">STARK Syntax Grammar
Specification</h1>
<h2 id="overview-1">Overview</h2>
<p>This document defines the concrete syntax grammar for STARK using
Extended Backus-Naur Form (EBNF).</p>
<h2 id="grammar-notation">Grammar Notation</h2>
<pre><code>::= means &quot;is defined as&quot;
|   means &quot;or&quot; (alternative)
?   means &quot;optional&quot; (zero or one)
*   means &quot;zero or more&quot;
+   means &quot;one or more&quot;
()  means &quot;grouping&quot;
[]  means &quot;optional&quot;
{}  means &quot;zero or more repetitions&quot;</code></pre>
<h2 id="top-level-grammar">Top-Level Grammar</h2>
<h3 id="program">Program</h3>
<pre class="ebnf"><code>Program ::= Item*

Item ::= Visibility? (Function
       | Struct
       | Enum  
       | Trait
       | Impl
       | Const
       | TypeAlias
       | Use
       | Module)

Visibility ::= &#39;pub&#39; | &#39;priv&#39;</code></pre>
<h3 id="function-definition">Function Definition</h3>
<pre class="ebnf"><code>Function ::= &#39;fn&#39; IDENTIFIER &#39;(&#39; ParameterList? &#39;)&#39; (&#39;-&gt;&#39; Type)? Block

ParameterList ::= Parameter (&#39;,&#39; Parameter)* &#39;,&#39;?

Parameter ::= IDENTIFIER &#39;:&#39; Type
            | &#39;mut&#39; IDENTIFIER &#39;:&#39; Type

Block ::= &#39;{&#39; Statement* &#39;}&#39;</code></pre>
<h3 id="data-type-definitions">Data Type Definitions</h3>
<pre class="ebnf"><code>Struct ::= &#39;struct&#39; IDENTIFIER &#39;{&#39; FieldList? &#39;}&#39;

FieldList ::= Field (&#39;,&#39; Field)* &#39;,&#39;?

Field ::= IDENTIFIER &#39;:&#39; Type
        | &#39;pub&#39; IDENTIFIER &#39;:&#39; Type

Enum ::= &#39;enum&#39; IDENTIFIER &#39;{&#39; VariantList? &#39;}&#39;

VariantList ::= Variant (&#39;,&#39; Variant)* &#39;,&#39;?

Variant ::= IDENTIFIER
          | IDENTIFIER &#39;(&#39; TypeList &#39;)&#39;
          | IDENTIFIER &#39;{&#39; FieldList &#39;}&#39;

Trait ::= &#39;trait&#39; IDENTIFIER &#39;{&#39; TraitItem* &#39;}&#39;

TraitItem ::= Function
            | Type

Impl ::= &#39;impl&#39; Type &#39;{&#39; ImplItem* &#39;}&#39;
       | &#39;impl&#39; IDENTIFIER &#39;for&#39; Type &#39;{&#39; ImplItem* &#39;}&#39;

ImplItem ::= Function</code></pre>
<h3 id="module-definition">Module Definition</h3>
<pre class="ebnf"><code>Module ::= &#39;mod&#39; IDENTIFIER &#39;;&#39;
        | &#39;mod&#39; IDENTIFIER ModuleBlock

ModuleBlock ::= &#39;{&#39; Item* &#39;}&#39;</code></pre>
<h3 id="type-alias">Type Alias</h3>
<pre class="ebnf"><code>TypeAlias ::= &#39;type&#39; IDENTIFIER &#39;=&#39; Type &#39;;&#39;</code></pre>
<h3 id="statements">Statements</h3>
<pre class="ebnf"><code>Statement ::= &#39;;&#39;                    // Empty statement
            | Expression &#39;;&#39;         // Expression statement
            | &#39;let&#39; LetStatement
            | &#39;return&#39; Expression? &#39;;&#39;
            | &#39;break&#39; Expression? &#39;;&#39;
            | &#39;continue&#39; &#39;;&#39;
            | Block

LetStatement ::= IDENTIFIER &#39;:&#39; Type &#39;;&#39;
               | &#39;mut&#39; IDENTIFIER &#39;:&#39; Type &#39;;&#39;
               | IDENTIFIER &#39;:&#39; Type &#39;=&#39; Expression &#39;;&#39;
               | IDENTIFIER &#39;=&#39; Expression &#39;;&#39;
               | &#39;mut&#39; IDENTIFIER &#39;:&#39; Type &#39;=&#39; Expression &#39;;&#39;
               | &#39;mut&#39; IDENTIFIER &#39;=&#39; Expression &#39;;&#39;</code></pre>
<h3 id="expressions">Expressions</h3>
<pre class="ebnf"><code>Expression ::= AssignmentExpression

AssignmentExpression ::= LogicalOrExpression
                       | LogicalOrExpression AssignOp AssignmentExpression

AssignOp ::= &#39;=&#39; | &#39;+=&#39; | &#39;-=&#39; | &#39;*=&#39; | &#39;/=&#39; | &#39;%=&#39; | &#39;**=&#39;
           | &#39;&amp;=&#39; | &#39;|=&#39; | &#39;^=&#39; | &#39;&lt;&lt;=&#39; | &#39;&gt;&gt;=&#39;

LogicalOrExpression ::= LogicalAndExpression (&#39;||&#39; LogicalAndExpression)*

LogicalAndExpression ::= EqualityExpression (&#39;&amp;&amp;&#39; EqualityExpression)*

EqualityExpression ::= RelationalExpression ((&#39;==&#39; | &#39;!=&#39;) RelationalExpression)*

RelationalExpression ::= BitwiseOrExpression ((&#39;&lt;&#39; | &#39;&lt;=&#39; | &#39;&gt;&#39; | &#39;&gt;=&#39;) BitwiseOrExpression)*

BitwiseOrExpression ::= BitwiseXorExpression (&#39;|&#39; BitwiseXorExpression)*

BitwiseXorExpression ::= BitwiseAndExpression (&#39;^&#39; BitwiseAndExpression)*

BitwiseAndExpression ::= ShiftExpression (&#39;&amp;&#39; ShiftExpression)*

ShiftExpression ::= AdditiveExpression ((&#39;&lt;&lt;&#39; | &#39;&gt;&gt;&#39;) AdditiveExpression)*

AdditiveExpression ::= MultiplicativeExpression ((&#39;+&#39; | &#39;-&#39;) MultiplicativeExpression)*

MultiplicativeExpression ::= ExponentiationExpression ((&#39;*&#39; | &#39;/&#39; | &#39;%&#39;) ExponentiationExpression)*

ExponentiationExpression ::= UnaryExpression (&#39;**&#39; ExponentiationExpression)?

UnaryExpression ::= PostfixExpression
                  | &#39;-&#39; UnaryExpression
                  | &#39;!&#39; UnaryExpression
                  | &#39;~&#39; UnaryExpression
                  | &#39;&amp;&#39; UnaryExpression        // Reference
                  | &#39;*&#39; UnaryExpression        // Dereference

PostfixExpression ::= PrimaryExpression
                    | PostfixExpression &#39;(&#39; ArgumentList? &#39;)&#39;     // Function call
                    | PostfixExpression &#39;[&#39; Expression &#39;]&#39;        // Array access
                    | PostfixExpression &#39;.&#39; IDENTIFIER            // Field access
                    | PostfixExpression &#39;.&#39; INTEGER               // Tuple access
                    | PostfixExpression &#39;?&#39;                       // Try operator

ArgumentList ::= Expression (&#39;,&#39; Expression)* &#39;,&#39;?

PrimaryExpression ::= IDENTIFIER
                    | Literal
                    | &#39;(&#39; Expression &#39;)&#39;
                    | ArrayLiteral
                    | StructLiteral
                    | IfExpression
                    | MatchExpression
                    | LoopExpression
                    | Block</code></pre>
<h3 id="control-flow-expressions">Control Flow Expressions</h3>
<pre class="ebnf"><code>IfExpression ::= &#39;if&#39; Expression Block (&#39;else&#39; &#39;if&#39; Expression Block)* (&#39;else&#39; Block)?

MatchExpression ::= &#39;match&#39; Expression &#39;{&#39; MatchArm* &#39;}&#39;

MatchArm ::= Pattern &#39;=&gt;&#39; Expression &#39;,&#39;?

Pattern ::= IDENTIFIER
          | Literal
          | &#39;_&#39;                                    // Wildcard
          | IDENTIFIER &#39;(&#39; PatternList? &#39;)&#39;        // Enum variant
          | &#39;(&#39; PatternList? &#39;)&#39;                   // Tuple
          | &#39;[&#39; PatternList? &#39;]&#39;                   // Array

PatternList ::= Pattern (&#39;,&#39; Pattern)* &#39;,&#39;?

LoopExpression ::= &#39;loop&#39; Block
                 | &#39;while&#39; Expression Block
                 | &#39;for&#39; IDENTIFIER &#39;in&#39; Expression Block</code></pre>
<h3 id="literals-1">Literals</h3>
<pre class="ebnf"><code>Literal ::= INTEGER
          | FLOAT
          | STRING
          | CHAR
          | BOOLEAN

ArrayLiteral ::= &#39;[&#39; ExpressionList? &#39;]&#39;

ExpressionList ::= Expression (&#39;,&#39; Expression)* &#39;,&#39;?

StructLiteral ::= IDENTIFIER &#39;{&#39; FieldInitList? &#39;}&#39;

FieldInitList ::= FieldInit (&#39;,&#39; FieldInit)* &#39;,&#39;?

FieldInit ::= IDENTIFIER &#39;:&#39; Expression
            | IDENTIFIER                    // Shorthand: field: field</code></pre>
<h3 id="types">Types</h3>
<pre class="ebnf"><code>Type ::= PrimitiveType
       | IDENTIFIER                        // Named type
       | &#39;[&#39; Type &#39;;&#39; INTEGER &#39;]&#39;          // Array type
       | &#39;[&#39; Type &#39;]&#39;                      // Slice type
       | &#39;(&#39; TypeList? &#39;)&#39;                 // Tuple type
       | &#39;&amp;&#39; Type                          // Reference type
       | &#39;&amp;&#39; &#39;mut&#39; Type                    // Mutable reference type
       | Type &#39;-&gt;&#39; Type                    // Function type

PrimitiveType ::= &#39;Int8&#39; | &#39;Int16&#39; | &#39;Int32&#39; | &#39;Int64&#39;
                | &#39;UInt8&#39; | &#39;UInt16&#39; | &#39;UInt32&#39; | &#39;UInt64&#39;
                | &#39;Float32&#39; | &#39;Float64&#39;
                | &#39;Bool&#39; | &#39;Char&#39; | &#39;String&#39; | &#39;Unit&#39; | &#39;str&#39;

TypeList ::= Type (&#39;,&#39; Type)* &#39;,&#39;?</code></pre>
<h3 id="other-constructs">Other Constructs</h3>
<pre class="ebnf"><code>Const ::= &#39;const&#39; IDENTIFIER &#39;:&#39; Type &#39;=&#39; Expression &#39;;&#39;

Use ::= &#39;use&#39; UseTree &#39;;&#39;

UseTree ::= Path (&#39;as&#39; IDENTIFIER)?
          | Path &#39;::&#39; &#39;*&#39;
          | Path &#39;::&#39; &#39;self&#39;
          | Path &#39;::&#39; &#39;{&#39; UseTreeList? &#39;}&#39;

UseTreeList ::= UseTree (&#39;,&#39; UseTree)* &#39;,&#39;?

Path ::= PathSegment (&#39;::&#39; PathSegment)*
PathSegment ::= IDENTIFIER | &#39;self&#39; | &#39;super&#39; | &#39;crate&#39;</code></pre>
<h2 id="operator-precedence-highest-to-lowest">Operator Precedence
(Highest to Lowest)</h2>
<ol type="1">
<li>Primary expressions, field access, array access, function calls, try
operator (<code>?</code>)</li>
<li>Unary operators (-, !, ~, &amp;, *)</li>
<li>Exponentiation (**)</li>
<li>Multiplicative (*, /, %)</li>
<li>Additive (+, -)</li>
<li>Shift (&lt;&lt;, &gt;&gt;)</li>
<li>Bitwise AND (&amp;)</li>
<li>Bitwise XOR (^)</li>
<li>Bitwise OR (|)</li>
<li>Relational (&lt;, &lt;=, &gt;, &gt;=)</li>
<li>Equality (==, !=)</li>
<li>Logical AND (&amp;&amp;)</li>
<li>Logical OR (||)</li>
<li>Assignment (=, +=, -=, etc.)</li>
</ol>
<h2 id="associativity">Associativity</h2>
<ul>
<li>Left associative: Most binary operators</li>
<li>Right associative: Assignment operators, exponentiation</li>
<li>Non-associative: Comparison operators</li>
</ul>
<h2 id="statement-vs-expression">Statement vs Expression</h2>
<ul>
<li>Statements do not return values and end with semicolons</li>
<li>Expressions return values and can be used as statements with
semicolons</li>
<li>Blocks are expressions (return value of last expression, or Unit if
none)</li>
<li>Control flow constructs are expressions</li>
</ul>
<h2 id="whitespace-and-semicolons">Whitespace and Semicolons</h2>
<ul>
<li>Semicolons are required to terminate statements</li>
<li>Semicolons are optional after the last expression in a block</li>
<li>Newlines are not significant except for line comments</li>
<li>Trailing commas are allowed in lists</li>
</ul>
<h2 id="grammar-extensions-for-future-features">Grammar Extensions for
Future Features</h2>
<p>Reserved grammar constructs for later implementation:</p>
<pre class="ebnf"><code>// Generic types (future)
GenericType ::= IDENTIFIER &#39;&lt;&#39; TypeList &#39;&gt;&#39;

// Async functions (future)
AsyncFunction ::= &#39;async&#39; &#39;fn&#39; IDENTIFIER &#39;(&#39; ParameterList? &#39;)&#39; (&#39;-&gt;&#39; Type)? Block

// Lambda expressions (future)
Lambda ::= &#39;|&#39; ParameterList? &#39;|&#39; (Expression | Block)</code></pre>
<h2 id="conformance-1">Conformance</h2>
<p>A conforming Core v1 implementation MUST follow the requirements in
this document. Any deviations or extensions MUST be explicitly
documented by the implementation.</p>
<hr />
<h1 id="stark-type-system-specification">STARK Type System
Specification</h1>
<h2 id="overview-2">Overview</h2>
<p>STARK features a static type system with type inference, ownership
semantics, and memory safety guarantees.</p>
<h2 id="core-principles-1">Core Principles</h2>
<ol type="1">
<li><strong>Static Typing</strong>: All types resolved at compile
time</li>
<li><strong>Type Inference</strong>: Types can be inferred when
unambiguous</li>
<li><strong>Memory Safety</strong>: No null pointer dereferences, no
use-after-free</li>
<li><strong>Ownership</strong>: Clear ownership and borrowing rules</li>
<li><strong>Zero-cost Abstractions</strong>: Type safety without runtime
overhead</li>
</ol>
<h2 id="primitive-types">Primitive Types</h2>
<h3 id="integer-types">Integer Types</h3>
<pre class="stark"><code>Int8    // 8-bit signed integer (-128 to 127)
Int16   // 16-bit signed integer (-32,768 to 32,767)
Int32   // 32-bit signed integer (-2^31 to 2^31-1)
Int64   // 64-bit signed integer (-2^63 to 2^63-1)

UInt8   // 8-bit unsigned integer (0 to 255)
UInt16  // 16-bit unsigned integer (0 to 65,535)
UInt32  // 32-bit unsigned integer (0 to 2^32-1)
UInt64  // 64-bit unsigned integer (0 to 2^64-1)</code></pre>
<p>Default integer type is <code>Int32</code> for literals that fit,
<code>Int64</code> otherwise.</p>
<h3 id="floating-point-types">Floating Point Types</h3>
<pre class="stark"><code>Float32  // 32-bit IEEE 754 floating point
Float64  // 64-bit IEEE 754 floating point</code></pre>
<p>Default floating point type is <code>Float64</code>.</p>
<h3 id="other-primitive-types">Other Primitive Types</h3>
<pre class="stark"><code>Bool    // Boolean: true or false
Char    // Unicode scalar value (32-bit)
Unit    // Unit type: () - represents no meaningful value
str     // String slice (unsized), typically used behind references: &amp;str</code></pre>
<h3 id="string-type">String Type</h3>
<pre class="stark"><code>String  // UTF-8 encoded string, heap-allocated, growable</code></pre>
<h3 id="string-slice-type">String Slice Type</h3>
<pre class="stark"><code>// str is an unsized string slice type. It is used via references.
let s: &amp;str = &quot;hello&quot;
let owned: String = String::from(s)</code></pre>
<h2 id="composite-types">Composite Types</h2>
<h3 id="array-types">Array Types</h3>
<pre class="stark"><code>[T; N]   // Fixed-size array of N elements of type T
[T]      // Dynamic array (slice) of elements of type T</code></pre>
<p>Examples:</p>
<pre class="stark"><code>let fixed: [Int32; 5] = [1, 2, 3, 4, 5]
let dynamic: [Int32] = [1, 2, 3]</code></pre>
<h3 id="tuple-types">Tuple Types</h3>
<pre class="stark"><code>()           // Empty tuple (Unit type)
(T,)         // Single-element tuple
(T1, T2)     // Two-element tuple
(T1, T2, T3) // Three-element tuple
// ... up to reasonable limit (e.g., 16 elements)</code></pre>
<p>Examples:</p>
<pre class="stark"><code>let empty: () = ()
let single: (Int32,) = (42,)
let pair: (Int32, String) = (42, &quot;hello&quot;)</code></pre>
<h3 id="struct-types">Struct Types</h3>
<pre class="stark"><code>struct Point {
    x: Float64,
    y: Float64
}

struct Person {
    name: String,
    age: Int32,
    pub email: String  // Public field
}</code></pre>
<h3 id="enum-types">Enum Types</h3>
<pre class="stark"><code>enum Color {
    Red,
    Green,
    Blue
}

enum Option&lt;T&gt; {
    Some(T),
    None
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E)
}</code></pre>
<h3 id="reference-types">Reference Types</h3>
<pre class="stark"><code>&amp;T       // Immutable reference to T
&amp;mut T   // Mutable reference to T</code></pre>
<h2 id="function-types">Function Types</h2>
<pre class="stark"><code>fn(T1, T2) -&gt; R    // Function taking T1, T2 and returning R
fn() -&gt; R          // Function taking no parameters, returning R
fn(T)              // Function taking T, returning Unit</code></pre>
<h2 id="type-aliases">Type Aliases</h2>
<pre class="stark"><code>type Age = Int32
type Point2D = (Float64, Float64)
type ErrorCode = Int32</code></pre>
<h2 id="ownership-and-borrowing-1">Ownership and Borrowing</h2>
<h3 id="ownership-rules">Ownership Rules</h3>
<ol type="1">
<li>Each value has exactly one owner</li>
<li>When the owner goes out of scope, the value is dropped</li>
<li>Values can be moved (ownership transfer) or borrowed (temporary
access)</li>
</ol>
<h3 id="move-semantics">Move Semantics</h3>
<pre class="stark"><code>let a = String::new(&quot;hello&quot;)
let b = a  // a is moved to b, a is no longer valid
// print(a)  // Error: use of moved value</code></pre>
<h3 id="borrowing-rules">Borrowing Rules</h3>
<ol type="1">
<li>You can have either one mutable reference or any number of immutable
references</li>
<li>References must always be valid (no dangling pointers)</li>
<li>References cannot outlive the data they refer to</li>
</ol>
<pre class="stark"><code>fn borrow_immutable(s: &amp;String) {
    // Can read but not modify
}

fn borrow_mutable(s: &amp;mut String) {
    // Can read and modify
}

let mut text = String::new(&quot;hello&quot;)
borrow_immutable(&amp;text)        // OK
borrow_mutable(&amp;mut text)      // OK
// borrow_immutable(&amp;text)     // Error: cannot borrow as immutable while mutable borrow exists</code></pre>
<h2 id="type-inference">Type Inference</h2>
<h3 id="local-type-inference">Local Type Inference</h3>
<pre class="stark"><code>let x = 42          // Inferred as Int32
let y = 3.14        // Inferred as Float64
let z = [1, 2, 3]   // Inferred as [Int32]</code></pre>
<h3 id="function-return-type-inference">Function Return Type
Inference</h3>
<pre class="stark"><code>fn add(a: Int32, b: Int32) {  // Return type inferred as Int32
    a + b
}</code></pre>
<h3 id="generic-type-inference">Generic Type Inference</h3>
<pre class="stark"><code>fn identity&lt;T&gt;(x: T) -&gt; T {
    x
}

let result = identity(42)  // T inferred as Int32</code></pre>
<h2 id="subtyping-and-coercion">Subtyping and Coercion</h2>
<h3 id="numeric-coercions">Numeric Coercions</h3>
<p>No implicit numeric conversions. Explicit casting required:</p>
<pre class="stark"><code>let x: Int32 = 42
let y: Int64 = x as Int64  // Explicit cast required</code></pre>
<h3 id="reference-coercions">Reference Coercions</h3>
<pre class="stark"><code>&amp;mut T -&gt; &amp;T        // Mutable reference to immutable reference
&amp;T -&gt; &amp;T            // Same type (identity)</code></pre>
<h3 id="array-to-slice-coercion">Array to Slice Coercion</h3>
<pre class="stark"><code>&amp;[T; N] -&gt; &amp;[T]     // Array reference to slice reference
&amp;mut [T; N] -&gt; &amp;mut [T]  // Mutable array reference to mutable slice reference</code></pre>
<h2 id="trait-system-basic">Trait System (Basic)</h2>
<h3 id="trait-definition">Trait Definition</h3>
<pre class="stark"><code>trait Display {
    fn fmt(&amp;self) -&gt; String
}

trait Eq {
    fn eq(&amp;self, other: &amp;Self) -&gt; Bool
}</code></pre>
<h3 id="trait-implementation">Trait Implementation</h3>
<pre class="stark"><code>impl Display for Int32 {
    fn fmt(&amp;self) -&gt; String {
        // Convert integer to string
    }
}

impl Eq for Point {
    fn eq(&amp;self, other: &amp;Point) -&gt; Bool {
        self.x == other.x &amp;&amp; self.y == other.y
    }
}</code></pre>
<h2 id="type-checking-rules">Type Checking Rules</h2>
<h3 id="assignment-compatibility">Assignment Compatibility</h3>
<pre class="stark"><code>let x: T = expr  // expr must have type T or be coercible to T</code></pre>
<h3 id="function-call-compatibility">Function Call Compatibility</h3>
<pre class="stark"><code>fn f(param: T) { ... }
f(arg)  // arg must have type T or be coercible to T</code></pre>
<h3 id="arithmetic-operations">Arithmetic Operations</h3>
<pre class="stark"><code>// Binary arithmetic requires same types
let result = x + y  // x and y must have the same numeric type

// Comparison operators
let cmp = x &lt; y     // x and y must have the same comparable type</code></pre>
<h3 id="logical-operations">Logical Operations</h3>
<pre class="stark"><code>let result = a &amp;&amp; b  // a and b must be Bool
let result = !x      // x must be Bool</code></pre>
<h2 id="error-types-and-handling">Error Types and Handling</h2>
<h3 id="option-type">Option Type</h3>
<pre class="stark"><code>enum Option&lt;T&gt; {
    Some(T),
    None
}</code></pre>
<h3 id="result-type">Result Type</h3>
<pre class="stark"><code>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E)
}</code></pre>
<h3 id="error-propagation">Error Propagation</h3>
<pre class="stark"><code>fn might_fail() -&gt; Result&lt;Int32, String&gt; {
    // ...
}

fn caller() -&gt; Result&lt;Int32, String&gt; {
    let value = might_fail()?  // Early return on error
    Ok(value * 2)
}</code></pre>
<h3 id="try-operator-typing">Try Operator (<code>?</code>) Typing</h3>
<p>The try operator is defined for <code>Result&lt;T, E&gt;</code> and
<code>Option&lt;T&gt;</code>: - If <code>expr</code> has type
<code>Result&lt;T, E&gt;</code>, then <code>expr?</code> has type
<code>T</code> and propagates <code>Err(E)</code> to the nearest
enclosing function returning <code>Result&lt;_, E&gt;</code>. - If
<code>expr</code> has type <code>Option&lt;T&gt;</code>, then
<code>expr?</code> has type <code>T</code> and propagates
<code>None</code> to the nearest enclosing function returning
<code>Option&lt;_&gt;</code>.</p>
<p>The enclosing function’s return type must be compatible with the
propagated type.</p>
<h2 id="type-system-extensions-future">Type System Extensions
(Future)</h2>
<h3 id="generics">Generics</h3>
<pre class="stark"><code>struct Vec&lt;T&gt; {
    data: [T],
    len: Int32,
    cap: Int32
}

fn max&lt;T: Ord&gt;(a: T, b: T) -&gt; T {
    if a &gt; b { a } else { b }
}</code></pre>
<h2 id="generics-core-v1">Generics (Core v1)</h2>
<p>Core v1 supports parametric polymorphism for functions, structs,
enums, and traits.</p>
<p>Rules: - Generic parameters are introduced with
<code>&lt;T, U, ...&gt;</code> after the item name. - Generic parameters
are in scope within the item body and signatures. - All generic
parameters used in an item MUST be declared by that item. -
Instantiation occurs at use sites; Core v1 permits monomorphization or
dictionary-passing, but the observable behavior MUST be equivalent.</p>
<h3 id="trait-bounds">Trait Bounds</h3>
<pre class="stark"><code>fn max&lt;T: Ord&gt;(a: T, b: T) -&gt; T { if a &gt; b { a } else { b } }</code></pre>
<p>Rules: - A bound <code>T: Trait</code> requires a visible
<code>impl Trait for T</code>. - Multiple bounds are allowed:
<code>T: TraitA + TraitB</code>.</p>
<h2 id="trait-coherence-core-v1">Trait Coherence (Core v1)</h2>
<p>To avoid ambiguous implementations, Core v1 applies the orphan rule:
- An <code>impl</code> is valid only if either the trait or the type is
defined in the current package.</p>
<p>Additionally: - If multiple applicable <code>impl</code> blocks could
apply to the same type at a call site, the program is ill-formed. -
Blanket implementations (e.g.,
<code>impl&lt;T: Trait&gt; OtherTrait for T</code>) are permitted but
must not violate coherence.</p>
<h2 id="numeric-semantics-core-v1">Numeric Semantics (Core v1)</h2>
<ul>
<li>Integer overflow and underflow are runtime errors and MUST
trap.</li>
<li>Division or modulo by zero is a runtime error and MUST trap.</li>
<li>Floating-point operations follow IEEE-754 semantics (NaN,
+/-Inf).</li>
</ul>
<h3 id="associated-types">Associated Types</h3>
<pre class="stark"><code>trait Iterator {
    type Item
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
}</code></pre>
<h3 id="lifetime-parameters">Lifetime Parameters</h3>
<pre class="stark"><code>fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre>
<h2 id="type-safety-guarantees">Type Safety Guarantees</h2>
<ol type="1">
<li><strong>No null pointer dereferences</strong>: Option type prevents
null access</li>
<li><strong>No buffer overflows</strong>: Array bounds checking</li>
<li><strong>No use-after-free</strong>: Ownership system prevents
dangling pointers</li>
<li><strong>No data races</strong>: Borrowing rules prevent concurrent
access violations</li>
<li><strong>No memory leaks</strong>: Automatic memory management
through ownership</li>
</ol>
<h2 id="implementation-notes">Implementation Notes</h2>
<h3 id="type-representation">Type Representation</h3>
<ul>
<li>Primitive types: Direct machine representation</li>
<li>Composite types: Laid out according to platform ABI</li>
<li>References: Pointers with compile-time tracking</li>
<li>Enums: Tagged unions with optimal layout</li>
</ul>
<h3 id="type-checking-algorithm">Type Checking Algorithm</h3>
<ol type="1">
<li>Parse source into AST</li>
<li>Build symbol table with declarations</li>
<li>Perform type inference using Hindley-Milner algorithm</li>
<li>Check type constraints and ownership rules</li>
<li>Generate type-annotated AST for code generation ## Conformance A
conforming Core v1 implementation MUST follow the requirements in this
document. Any deviations or extensions MUST be explicitly documented by
the implementation.</li>
</ol>
<hr />
<h1 id="stark-semantic-analysis-specification">STARK Semantic Analysis
Specification</h1>
<h2 id="overview-3">Overview</h2>
<p>Semantic analysis validates that programs are meaningful according to
STARK’s language rules. This phase occurs after parsing and before code
generation.</p>
<h2 id="analysis-phases">Analysis Phases</h2>
<h3 id="symbol-table-construction">1. Symbol Table Construction</h3>
<p>Build symbol tables for scopes and declarations.</p>
<h4 id="scope-rules">Scope Rules</h4>
<pre class="stark"><code>// Global scope
fn global_function() { }
const GLOBAL_CONST: Int32 = 42

fn example() {
    // Function scope
    let local_var = 10
    
    {
        // Block scope
        let block_var = 20
        // block_var accessible here
        // local_var accessible here
    }
    // block_var not accessible here
    // local_var still accessible
}</code></pre>
<h4 id="name-resolution-order">Name Resolution Order</h4>
<ol type="1">
<li>Current scope</li>
<li>Parent scopes (innermost to outermost)</li>
<li>Global scope</li>
<li>Built-in names</li>
</ol>
<h4 id="shadowing-rules">Shadowing Rules</h4>
<pre class="stark"><code>let x = 10        // x: Int32
{
    let x = &quot;hi&quot;  // Shadows outer x, x: String
    // Inner x takes precedence
}
// Outer x visible again</code></pre>
<h3 id="type-checking">2. Type Checking</h3>
<h4 id="variable-declarations">Variable Declarations</h4>
<pre class="stark"><code>let x: Int32 = 42      // Type annotation matches literal
let y = 42             // Type inferred as Int32
let z: String = 42     // Error: type mismatch</code></pre>
<h4 id="function-calls">Function Calls</h4>
<pre class="stark"><code>fn add(a: Int32, b: Int32) -&gt; Int32 { a + b }

let result = add(1, 2)     // OK: arguments match parameters
let error = add(1.0, 2)    // Error: Float64 cannot be Int32
let error2 = add(1)        // Error: wrong number of arguments</code></pre>
<h4 id="assignment-compatibility-1">Assignment Compatibility</h4>
<pre class="stark"><code>let mut x: Int32 = 10
x = 20                     // OK: same type
x = &quot;hello&quot;                // Error: type mismatch

let y: Int32 = 10
y = 20                     // Error: y is not mutable</code></pre>
<h3 id="ownership-and-borrowing-analysis">3. Ownership and Borrowing
Analysis</h3>
<h4 id="move-semantics-validation">Move Semantics Validation</h4>
<pre class="stark"><code>let s1 = String::new(&quot;hello&quot;)
let s2 = s1               // s1 moved to s2
print(s1)                 // Error: use of moved value

fn take_ownership(s: String) { }
let s3 = String::new(&quot;world&quot;)
take_ownership(s3)        // s3 moved into function
print(s3)                 // Error: use of moved value</code></pre>
<h4 id="borrow-checking">Borrow Checking</h4>
<pre class="stark"><code>let mut s = String::new(&quot;hello&quot;)
let r1 = &amp;s               // Immutable borrow
let r2 = &amp;s               // OK: multiple immutable borrows
let r3 = &amp;mut s           // Error: cannot borrow mutably while immutably borrowed

let mut s2 = String::new(&quot;world&quot;)
let r4 = &amp;mut s2          // Mutable borrow
let r5 = &amp;s2              // Error: cannot borrow immutably while mutably borrowed
let r6 = &amp;mut s2          // Error: cannot have multiple mutable borrows</code></pre>
<h4 id="lifetime-validation">Lifetime Validation</h4>
<pre class="stark"><code>fn invalid_return() -&gt; &amp;Int32 {
    let x = 42
    &amp;x                    // Error: returning reference to local variable
}

fn valid_return(x: &amp;Int32) -&gt; &amp;Int32 {
    x                     // OK: returning input reference
}</code></pre>
<h3 id="control-flow-analysis">4. Control Flow Analysis</h3>
<h4 id="unreachable-code-detection">Unreachable Code Detection</h4>
<pre class="stark"><code>fn example() -&gt; Int32 {
    return 42
    let x = 10            // Warning: unreachable code
}</code></pre>
<h4 id="return-path-analysis">Return Path Analysis</h4>
<pre class="stark"><code>fn missing_return() -&gt; Int32 {
    let x = 42
    // Error: not all paths return a value
}

fn conditional_return(flag: Bool) -&gt; Int32 {
    if flag {
        return 1
    }
    // Error: missing return in else branch
}

fn valid_return(flag: Bool) -&gt; Int32 {
    if flag {
        1
    } else {
        2
    }                     // OK: both branches return
}</code></pre>
<h4 id="breakcontinue-validation">Break/Continue Validation</h4>
<pre class="stark"><code>fn invalid_break() {
    break                 // Error: break outside of loop
}

fn valid_break() {
    loop {
        break             // OK: break inside loop
    }
}</code></pre>
<h3 id="pattern-matching-analysis">5. Pattern Matching Analysis</h3>
<h4 id="exhaustiveness-checking">Exhaustiveness Checking</h4>
<pre class="stark"><code>enum Color { Red, Green, Blue }

fn check_color(c: Color) -&gt; String {
    match c {
        Color::Red =&gt; &quot;red&quot;,
        Color::Green =&gt; &quot;green&quot;
        // Error: non-exhaustive pattern (missing Blue)
    }
}

fn valid_match(c: Color) -&gt; String {
    match c {
        Color::Red =&gt; &quot;red&quot;,
        Color::Green =&gt; &quot;green&quot;,
        Color::Blue =&gt; &quot;blue&quot;     // OK: exhaustive
    }
}</code></pre>
<p>Rules: - A <code>match</code> over an enum type is exhaustive if
every variant is covered, or a wildcard (<code>_</code>) arm exists. -
Tuple patterns are exhaustive if each element position is exhaustive for
its type. - Literal patterns are exhaustive only for finite domains
(e.g., <code>Bool</code> with <code>true</code> and <code>false</code>).
- If a match is not exhaustive, it is a compile-time error.</p>
<h4 id="pattern-type-checking">Pattern Type Checking</h4>
<pre class="stark"><code>let x: Int32 = 42
match x {
    &quot;hello&quot; =&gt; &quot;string&quot;,          // Error: pattern type mismatch
    42 =&gt; &quot;number&quot;                // OK
}</code></pre>
<h3 id="mutability-analysis">6. Mutability Analysis</h3>
<h4 id="mutable-access-validation">Mutable Access Validation</h4>
<pre class="stark"><code>let x = 42
x = 43                    // Error: x is not mutable

let mut y = 42
y = 43                    // OK: y is mutable

struct Point { x: Int32, y: Int32 }
let p = Point { x: 1, y: 2 }
p.x = 10                  // Error: p is not mutable

let mut p2 = Point { x: 1, y: 2 }
p2.x = 10                 // OK: p2 is mutable</code></pre>
<h3 id="initialization-analysis">7. Initialization Analysis</h3>
<h4 id="use-before-initialization">Use Before Initialization</h4>
<pre class="stark"><code>let x: Int32
print(x)                  // Error: use of uninitialized variable

let y: Int32 = if true { 42 } else { 24 }
print(y)                  // OK: y is initialized in all branches

let z: Int32
if condition {
    z = 42
}
print(z)                  // Error: z might not be initialized</code></pre>
<p>Rules: - <code>let name: Type;</code> declares a variable without
initializing it. - A variable must be definitely assigned before any
read. - All control-flow paths must assign before use.</p>
<h4 id="double-initialization">Double Initialization</h4>
<pre class="stark"><code>let mut x: Int32 = 42
x = 43                    // OK: reassignment
let x = 44                // Error: redeclaration in same scope</code></pre>
<h3 id="array-bounds-analysis">8. Array Bounds Analysis</h3>
<h4 id="static-bounds-checking">Static Bounds Checking</h4>
<pre class="stark"><code>let arr: [Int32; 3] = [1, 2, 3]
let x = arr[2]            // OK: index in bounds
let y = arr[5]            // Error: index out of bounds (if determinable)</code></pre>
<h4 id="dynamic-bounds-checking">Dynamic Bounds Checking</h4>
<pre class="stark"><code>let arr: [Int32] = [1, 2, 3]
let idx = get_index()
let x = arr[idx]          // Runtime bounds check required</code></pre>
<h3 id="error-propagation-analysis">9. Error Propagation Analysis</h3>
<h4 id="question-mark-operator">Question Mark Operator</h4>
<pre class="stark"><code>fn might_fail() -&gt; Result&lt;Int32, String&gt; { ... }

fn caller1() -&gt; Result&lt;Int32, String&gt; {
    let x = might_fail()?     // OK: compatible error types
    Ok(x * 2)
}

fn caller2() -&gt; Int32 {
    let x = might_fail()?     // Error: function doesn&#39;t return Result
    x * 2
}</code></pre>
<p>Rules: - <code>expr?</code> propagates <code>Err</code> or
<code>None</code> to the nearest enclosing function returning
<code>Result&lt;_, E&gt;</code> or <code>Option&lt;_&gt;</code>. - The
enclosing function return type must be compatible with the propagated
type.</p>
<h2 id="runtime-error-semantics-core-v1">Runtime Error Semantics (Core
v1)</h2>
<ul>
<li>A runtime error (e.g., integer overflow, division by zero,
out-of-bounds indexing) MUST terminate the current program
execution.</li>
<li><code>panic(...)</code> is a runtime error that terminates the
program after emitting the provided message.</li>
</ul>
<h3 id="trait-constraint-checking">10. Trait Constraint Checking</h3>
<h4 id="trait-bounds-validation">Trait Bounds Validation</h4>
<pre class="stark"><code>trait Display {
    fn fmt(&amp;self) -&gt; String
}

fn print_it&lt;T: Display&gt;(item: T) {
    print(item.fmt())         // OK: T implements Display
}

struct Point { x: Int32, y: Int32 }

print_it(Point { x: 1, y: 2 })  // Error: Point doesn&#39;t implement Display</code></pre>
<h2 id="error-reporting">Error Reporting</h2>
<h3 id="error-message-format">Error Message Format</h3>
<pre><code>Error: [ERROR_CODE] [BRIEF_DESCRIPTION]
  --&gt; file.stark:line:column
   |
line | source code line
   | ^^^^^ specific location
   |
   = help: detailed explanation
   = note: additional information</code></pre>
<h3 id="error-categories">Error Categories</h3>
<h4 id="type-errors-e0001-e0099">Type Errors (E0001-E0099)</h4>
<ul>
<li>E0001: Type mismatch</li>
<li>E0002: Unknown type</li>
<li>E0003: Type annotation required</li>
<li>E0004: Cannot infer type</li>
</ul>
<h4 id="ownership-errors-e0100-e0199">Ownership Errors
(E0100-E0199)</h4>
<ul>
<li>E0100: Use of moved value</li>
<li>E0101: Borrow check failed</li>
<li>E0102: Lifetime violation</li>
<li>E0103: Dangling reference</li>
</ul>
<h4 id="name-resolution-errors-e0200-e0299">Name Resolution Errors
(E0200-E0299)</h4>
<ul>
<li>E0200: Undefined variable</li>
<li>E0201: Undefined function</li>
<li>E0202: Undefined type</li>
<li>E0203: Ambiguous name</li>
</ul>
<h4 id="control-flow-errors-e0300-e0399">Control Flow Errors
(E0300-E0399)</h4>
<ul>
<li>E0300: Unreachable code</li>
<li>E0301: Missing return value</li>
<li>E0302: Break outside loop</li>
<li>E0303: Non-exhaustive match</li>
</ul>
<h3 id="warning-categories">Warning Categories</h3>
<h4 id="unused-items-w0001-w0099">Unused Items (W0001-W0099)</h4>
<ul>
<li>W0001: Unused variable</li>
<li>W0002: Unused function</li>
<li>W0003: Unused import</li>
<li>W0004: Dead code</li>
</ul>
<h4 id="style-warnings-w0100-w0199">Style Warnings (W0100-W0199)</h4>
<ul>
<li>W0100: Non-snake_case variable</li>
<li>W0101: Non-PascalCase type</li>
<li>W0102: Missing documentation</li>
</ul>
<h2 id="analysis-algorithm">Analysis Algorithm</h2>
<h3 id="pass-order">Pass Order</h3>
<ol type="1">
<li><strong>Declaration Pass</strong>: Collect all top-level
declarations</li>
<li><strong>Type Resolution Pass</strong>: Resolve all type
expressions</li>
<li><strong>Type Inference Pass</strong>: Infer types for
expressions</li>
<li><strong>Ownership Pass</strong>: Check ownership and borrowing
rules</li>
<li><strong>Control Flow Pass</strong>: Analyze control flow and
reachability</li>
<li><strong>Pattern Pass</strong>: Check pattern exhaustiveness and
types</li>
<li><strong>Constraint Pass</strong>: Validate trait constraints and
bounds</li>
</ol>
<h3 id="dependency-resolution">Dependency Resolution</h3>
<ul>
<li>Forward references allowed for types and functions</li>
<li>Circular dependencies detected and reported</li>
<li>Initialization order determined for constants</li>
</ul>
<h3 id="error-recovery">Error Recovery</h3>
<ul>
<li>Continue analysis after errors when possible</li>
<li>Provide multiple related errors in single pass</li>
<li>Suggest fixes when unambiguous</li>
<li>Avoid cascading errors from single root cause</li>
</ul>
<h2 id="implementation-considerations">Implementation
Considerations</h2>
<h3 id="symbol-table-structure">Symbol Table Structure</h3>
<div class="sourceCode" id="cb93"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> SymbolTable <span class="op">{</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    symbols<span class="op">:</span> HashMap<span class="op">&lt;</span><span class="dt">String</span><span class="op">,</span> Symbol<span class="op">&gt;,</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    parent<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;&amp;</span>SymbolTable<span class="op">&gt;,</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>    children<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>SymbolTable<span class="op">&gt;</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Symbol <span class="op">{</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    Variable <span class="op">{</span> ty<span class="op">:</span> Type<span class="op">,</span> mutable<span class="op">:</span> <span class="dt">bool</span><span class="op">,</span> initialized<span class="op">:</span> <span class="dt">bool</span> <span class="op">},</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>    Function <span class="op">{</span> params<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>Type<span class="op">&gt;,</span> return_ty<span class="op">:</span> Type <span class="op">},</span></span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>    Type <span class="op">{</span> definition<span class="op">:</span> TypeDef <span class="op">},</span></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a>    Constant <span class="op">{</span> ty<span class="op">:</span> Type<span class="op">,</span> value<span class="op">:</span> Value <span class="op">}</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="type-checking-context">Type Checking Context</h3>
<div class="sourceCode" id="cb94"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> TypeContext <span class="op">{</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    current_function<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span>FunctionId<span class="op">&gt;,</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    expected_return_type<span class="op">:</span> <span class="dt">Option</span><span class="op">&lt;</span>Type<span class="op">&gt;,</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    loop_depth<span class="op">:</span> <span class="dt">usize</span><span class="op">,</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>    borrowed_values<span class="op">:</span> HashMap<span class="op">&lt;</span>ValueId<span class="op">,</span> BorrowInfo<span class="op">&gt;</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="error-collection">Error Collection</h3>
<div class="sourceCode" id="cb95"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> ErrorReporter <span class="op">{</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    errors<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>SemanticError<span class="op">&gt;,</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>    warnings<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span>SemanticWarning<span class="op">&gt;,</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    error_limit<span class="op">:</span> <span class="dt">usize</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="conformance-2">Conformance</h2>
<p>A conforming Core v1 implementation MUST follow the requirements in
this document. Any deviations or extensions MUST be explicitly
documented by the implementation.</p>
<hr />
<h1 id="stark-memory-model-and-ownership-specification">STARK Memory
Model and Ownership Specification</h1>
<h2 id="overview-4">Overview</h2>
<p>STARK’s memory model ensures memory safety without garbage collection
through compile-time ownership tracking, similar to Rust but with some
simplifications for the initial implementation.</p>
<h2 id="core-principles-2">Core Principles</h2>
<h3 id="ownership">1. Ownership</h3>
<ul>
<li>Every value has exactly one owner</li>
<li>When the owner goes out of scope, the value is dropped</li>
<li>Ownership can be transferred (moved) but not duplicated</li>
</ul>
<h3 id="borrowing">2. Borrowing</h3>
<ul>
<li>Values can be borrowed without transferring ownership</li>
<li>Immutable borrows allow reading</li>
<li>Mutable borrows allow reading and writing</li>
<li>Borrowing rules prevent data races at compile time</li>
</ul>
<h3 id="lifetimes">3. Lifetimes</h3>
<ul>
<li>All references have a lifetime</li>
<li>References cannot outlive the data they point to</li>
<li>Lifetimes are mostly inferred by the compiler</li>
</ul>
<h2 id="memory-layout">Memory Layout</h2>
<h3 id="stack-allocation">Stack Allocation</h3>
<pre class="stark"><code>// Stack-allocated values
let x: Int32 = 42           // x stored on stack
let y: [Int32; 4] = [1,2,3,4]  // y stored on stack

struct Point { x: Float64, y: Float64 }
let p: Point = Point { x: 1.0, y: 2.0 }  // p stored on stack</code></pre>
<h3 id="heap-allocation">Heap Allocation</h3>
<pre class="stark"><code>// Heap-allocated values
let s: String = String::new(&quot;hello&quot;)     // String data on heap
let v: Vec&lt;Int32&gt; = Vec::new()          // Vec data on heap
let b: Box&lt;Int32&gt; = Box::new(42)        // Boxed value on heap</code></pre>
<h3 id="reference-layout">Reference Layout</h3>
<pre class="stark"><code>// References are pointers (8 bytes on 64-bit)
let x: Int32 = 42
let r: &amp;Int32 = &amp;x          // r contains address of x

// Slices contain pointer + length
let arr: [Int32; 5] = [1,2,3,4,5]
let slice: &amp;[Int32] = &amp;arr[1..4]  // pointer + length (16 bytes)</code></pre>
<h2 id="ownership-rules-1">Ownership Rules</h2>
<h3 id="rule-1-single-ownership">Rule 1: Single Ownership</h3>
<pre class="stark"><code>let s1 = String::new(&quot;hello&quot;)
let s2 = s1                 // Ownership moved from s1 to s2
// println(s1)              // Error: s1 no longer valid
println(s2)                 // OK: s2 owns the string</code></pre>
<h3 id="rule-2-automatic-cleanup">Rule 2: Automatic Cleanup</h3>
<pre class="stark"><code>{
    let s = String::new(&quot;hello&quot;)  // s owns the string
    // String is automatically freed when s goes out of scope
}</code></pre>
<h3 id="rule-3-function-parameters">Rule 3: Function Parameters</h3>
<pre class="stark"><code>fn take_ownership(s: String) {
    // s is owned by this function
    println(s)
    // s is dropped when function returns
}

fn main() {
    let s = String::new(&quot;hello&quot;)
    take_ownership(s)       // Ownership transferred to function
    // println(s)           // Error: s no longer valid
}</code></pre>
<h2 id="move-semantics-1">Move Semantics</h2>
<h3 id="what-gets-moved">What Gets Moved</h3>
<p>Types are moved if they: 1. Don’t implement the <code>Copy</code>
trait 2. Contain non-Copy fields</p>
<pre class="stark"><code>// Types that are moved by default
String, Vec&lt;T&gt;, Box&lt;T&gt;, custom structs without Copy

// Types that are copied by default (implement Copy)
Int32, Float64, Bool, Char, &amp;T, [T; N] where T: Copy</code></pre>
<h3 id="move-in-assignments">Move in Assignments</h3>
<pre class="stark"><code>let s1 = String::new(&quot;hello&quot;)
let s2 = s1                 // Move
let s3 = s2.clone()         // Explicit copy (if Clone implemented)</code></pre>
<h3 id="move-in-function-calls">Move in Function Calls</h3>
<pre class="stark"><code>fn process(s: String) { ... }

let my_string = String::new(&quot;hello&quot;)
process(my_string)          // my_string moved into function
// my_string no longer accessible</code></pre>
<h3 id="move-in-returns">Move in Returns</h3>
<pre class="stark"><code>fn create_string() -&gt; String {
    let s = String::new(&quot;hello&quot;)
    s                       // Ownership moved to caller
}</code></pre>
<h2 id="borrowing-system">Borrowing System</h2>
<h3 id="immutable-borrowing">Immutable Borrowing</h3>
<pre class="stark"><code>fn read_string(s: &amp;String) -&gt; Int32 {
    s.len()                 // Can read but not modify
}

let my_string = String::new(&quot;hello&quot;)
let length = read_string(&amp;my_string)  // Borrow my_string
println(my_string)          // my_string still accessible</code></pre>
<h3 id="mutable-borrowing">Mutable Borrowing</h3>
<pre class="stark"><code>fn modify_string(s: &amp;mut String) {
    s.push(&#39;!&#39;)             // Can read and modify
}

let mut my_string = String::new(&quot;hello&quot;)
modify_string(&amp;mut my_string)         // Mutable borrow
println(my_string)          // Prints &quot;hello!&quot;</code></pre>
<h3 id="borrowing-rules-1">Borrowing Rules</h3>
<ol type="1">
<li><strong>Either</strong> one mutable borrow <strong>OR</strong> any
number of immutable borrows</li>
<li>References must always be valid</li>
</ol>
<pre class="stark"><code>let mut s = String::new(&quot;hello&quot;)

// Multiple immutable borrows - OK
let r1 = &amp;s
let r2 = &amp;s
println(&quot;{} {}&quot;, r1, r2)

// Mutable and immutable borrow - Error
let r3 = &amp;s
let r4 = &amp;mut s             // Error: cannot borrow mutably while immutably borrowed

// Multiple mutable borrows - Error
let r5 = &amp;mut s
let r6 = &amp;mut s             // Error: cannot borrow mutably twice</code></pre>
<h2 id="lifetime-system">Lifetime System</h2>
<h3 id="lifetime-basics">Lifetime Basics</h3>
<pre class="stark"><code>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
// Compiler infers that return value has same lifetime as input parameters</code></pre>
<h3 id="lifetime-annotations-future-feature">Lifetime Annotations
(Future Feature)</h3>
<pre class="stark"><code>fn longest&lt;&#39;a&gt;(x: &amp;&#39;a str, y: &amp;&#39;a str) -&gt; &amp;&#39;a str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre>
<h3 id="dangling-reference-prevention">Dangling Reference
Prevention</h3>
<pre class="stark"><code>fn invalid() -&gt; &amp;Int32 {
    let x = 42
    &amp;x                      // Error: returning reference to local variable
}

fn valid(x: &amp;Int32) -&gt; &amp;Int32 {
    x                       // OK: returning input reference
}</code></pre>
<h2 id="memory-management-strategies">Memory Management Strategies</h2>
<h3 id="stack-vs-heap-decision">Stack vs Heap Decision</h3>
<pre class="stark"><code>// Stack allocated (small, known size)
let point = Point { x: 1.0, y: 2.0 }
let array = [1, 2, 3, 4, 5]

// Heap allocated (dynamic size, large objects)
let string = String::new(&quot;hello&quot;)
let vector = Vec::new()
let boxed = Box::new(large_object)</code></pre>
<h3 id="reference-counting-rcarc">Reference Counting (Rc/Arc)</h3>
<pre class="stark"><code>// Single-threaded reference counting (future feature)
let data = Rc::new(vec![1, 2, 3])
let data2 = data.clone()    // Increment reference count

// Multi-threaded reference counting (future feature)
let shared = Arc::new(vec![1, 2, 3])
let shared2 = shared.clone()</code></pre>
<h2 id="drop-and-destructors">Drop and Destructors</h2>
<h3 id="automatic-drop">Automatic Drop</h3>
<pre class="stark"><code>struct FileHandle {
    path: String,
    handle: Int32
}

impl Drop for FileHandle {
    fn drop(&amp;mut self) {
        // Close file handle
        close_file(self.handle)
    }
}

{
    let file = FileHandle { path: &quot;test.txt&quot;.to_string(), handle: 42 }
    // file.drop() called automatically when leaving scope
}</code></pre>
<h3 id="drop-order">Drop Order</h3>
<pre class="stark"><code>{
    let x = String::new(&quot;first&quot;)
    let y = String::new(&quot;second&quot;)
    let z = String::new(&quot;third&quot;)
    // Drop order: z, y, x (reverse declaration order)
}</code></pre>
<h3 id="manual-drop">Manual Drop</h3>
<pre class="stark"><code>let s = String::new(&quot;hello&quot;)
drop(s)                     // Explicitly drop s
// println(s)               // Error: s has been dropped</code></pre>
<h2 id="copy-vs-move-types">Copy vs Move Types</h2>
<h3 id="copy-types">Copy Types</h3>
<p>Implement <code>Copy</code> trait - assignment creates a copy, not a
move:</p>
<pre class="stark"><code>// Built-in Copy types
Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64
Float32, Float64, Bool, Char, Unit
&amp;T (references), [T; N] where T: Copy

// Usage
let x: Int32 = 42
let y = x                   // x is copied, still accessible
println(&quot;{} {}&quot;, x, y)      // OK: both x and y valid</code></pre>
<h3 id="move-types">Move Types</h3>
<p>Do not implement <code>Copy</code> - assignment moves ownership:</p>
<pre class="stark"><code>// Built-in Move types
String, Vec&lt;T&gt;, Box&lt;T&gt;, HashMap&lt;K, V&gt;

// Custom types are Move by default
struct Person {
    name: String,
    age: Int32
}

let p1 = Person { name: &quot;Alice&quot;.to_string(), age: 30 }
let p2 = p1                 // p1 moved to p2
// println(p1.name)         // Error: p1 no longer valid</code></pre>
<h2 id="smart-pointers">Smart Pointers</h2>
<h3 id="box---heap-allocation">Box<T> - Heap Allocation</h3>
<pre class="stark"><code>let boxed_int = Box::new(42)
let large_array = Box::new([0; 1000])  // Allocate large array on heap</code></pre>
<h3 id="rc---reference-counting-future">Rc<T> - Reference Counting
(Future)</h3>
<pre class="stark"><code>let data = Rc::new(vec![1, 2, 3])
let reference1 = data.clone()    // Increment reference count
let reference2 = data.clone()    // Increment reference count
// Data deallocated when all references dropped</code></pre>
<h3 id="refcell---interior-mutability-future">RefCell<T> - Interior
Mutability (Future)</h3>
<pre class="stark"><code>let data = RefCell::new(42)
{
    let mut borrowed = data.borrow_mut()  // Runtime borrow check
    *borrowed = 43
}
println(data.borrow())      // Prints 43</code></pre>
<h2 id="memory-safety-guarantees">Memory Safety Guarantees</h2>
<h3 id="what-stark-prevents">What STARK Prevents</h3>
<ol type="1">
<li><strong>Null pointer dereferences</strong>: No null pointers, use
Option<T></li>
<li><strong>Buffer overflows</strong>: Array bounds checking</li>
<li><strong>Use after free</strong>: Ownership system prevents dangling
pointers</li>
<li><strong>Double free</strong>: Ownership ensures single
deallocation</li>
<li><strong>Memory leaks</strong>: Automatic cleanup through
ownership</li>
<li><strong>Data races</strong>: Borrowing rules prevent concurrent
access</li>
</ol>
<h3 id="runtime-checks">Runtime Checks</h3>
<p>Some checks remain at runtime: - Array bounds checking (unless
optimized away) - Integer overflow (in debug mode) - RefCell borrow
checking (future feature)</p>
<h2 id="performance-considerations">Performance Considerations</h2>
<h3 id="zero-cost-abstractions">Zero-Cost Abstractions</h3>
<ul>
<li>Ownership and borrowing have no runtime cost</li>
<li>References are just pointers</li>
<li>Move semantics avoid unnecessary copies</li>
</ul>
<h3 id="optimization-opportunities">Optimization Opportunities</h3>
<ul>
<li>Dead code elimination for unused values</li>
<li>Lifetime optimization to reduce copies</li>
<li>Stack allocation for escaped values when possible</li>
</ul>
<h3 id="memory-layout-optimization">Memory Layout Optimization</h3>
<ul>
<li>Struct field reordering to minimize padding</li>
<li>Enum layout optimization for tagged unions</li>
<li>Array and slice bounds check elimination</li>
</ul>
<h2 id="implementation-notes-1">Implementation Notes</h2>
<h3 id="compiler-phases">Compiler Phases</h3>
<ol type="1">
<li><strong>Ownership Analysis</strong>: Track value ownership through
program</li>
<li><strong>Borrow Checking</strong>: Validate borrowing rules</li>
<li><strong>Lifetime Inference</strong>: Determine reference
lifetimes</li>
<li><strong>Drop Insertion</strong>: Insert drop calls at scope
exits</li>
<li><strong>Memory Layout</strong>: Determine stack vs heap
allocation</li>
</ol>
<h3 id="error-messages">Error Messages</h3>
<pre><code>Error: borrow of moved value
  --&gt; example.stark:10:5
   |
 8 |     let s1 = String::new(&quot;hello&quot;);
   |         -- move occurs because `s1` has type `String`
 9 |     let s2 = s1;
   |              -- value moved here
10 |     println(s1);
   |     ^^ value borrowed here after move</code></pre>
<h3 id="integration-with-type-system">Integration with Type System</h3>
<ul>
<li>Ownership information included in type signatures</li>
<li>Borrowing constraints encoded in function types</li>
<li>Lifetime parameters for generic functions (future)</li>
</ul>
<h2 id="future-extensions">Future Extensions</h2>
<h3 id="advanced-features">Advanced Features</h3>
<ul>
<li>Lifetime parameters and annotations</li>
<li>Higher-ranked trait bounds</li>
<li>Associated types with lifetime parameters</li>
<li>Async/await with proper lifetime handling ## Conformance A
conforming Core v1 implementation MUST follow the requirements in this
document. Any deviations or extensions MUST be explicitly documented by
the implementation.</li>
</ul>
<hr />
<h1 id="stark-standard-library-specification">STARK Standard Library
Specification</h1>
<h2 id="overview-5">Overview</h2>
<p>The STARK standard library provides essential types, functions, and
modules for core programming tasks. This specification defines the
minimal standard library for the initial implementation.</p>
<h2 id="core-module-structure">Core Module Structure</h2>
<pre><code>std/
├── core/           // Core language items
├── collections/    // Data structures
├── io/            // Input/output operations
├── string/        // String manipulation
├── math/          // Mathematical operations
├── mem/           // Memory management utilities
├── error/         // Error handling types
└── prelude/       // Automatically imported items</code></pre>
<h2 id="prelude-module">Prelude Module</h2>
<p>Automatically imported into every STARK program:</p>
<pre class="stark"><code>// Basic types (no import needed)
Int8, Int16, Int32, Int64, UInt8, UInt16, UInt32, UInt64
Float32, Float64, Bool, Char, String, str, Unit

// Essential traits
trait Copy
trait Clone
trait Drop
trait Eq
trait Ord

// Essential types
enum Option&lt;T&gt; {
    Some(T),
    None
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E)
}

// Essential functions
fn print(value: &amp;str)
fn println(value: &amp;str)
fn panic(message: &amp;str) -&gt; !</code></pre>
<h2 id="core-module-stdcore">Core Module (std::core)</h2>
<h3 id="memory-management">Memory Management</h3>
<pre class="stark"><code>// Box - heap allocation
struct Box&lt;T&gt; {
    ptr: *mut T
}

impl&lt;T&gt; Box&lt;T&gt; {
    fn new(value: T) -&gt; Box&lt;T&gt;
    fn into_inner(self) -&gt; T
}

// Manual memory management
fn drop&lt;T&gt;(value: T)
fn size_of&lt;T&gt;() -&gt; UInt64
fn align_of&lt;T&gt;() -&gt; UInt64</code></pre>
<h3 id="option-type-1">Option Type</h3>
<pre class="stark"><code>enum Option&lt;T&gt; {
    Some(T),
    None
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn is_some(&amp;self) -&gt; Bool
    fn is_none(&amp;self) -&gt; Bool
    fn unwrap(self) -&gt; T
    fn unwrap_or(self, default: T) -&gt; T
    fn map&lt;U&gt;(self, f: fn(T) -&gt; U) -&gt; Option&lt;U&gt;
    fn and_then&lt;U&gt;(self, f: fn(T) -&gt; Option&lt;U&gt;) -&gt; Option&lt;U&gt;
}</code></pre>
<h3 id="result-type-1">Result Type</h3>
<pre class="stark"><code>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E)
}

impl&lt;T, E&gt; Result&lt;T, E&gt; {
    fn is_ok(&amp;self) -&gt; Bool
    fn is_err(&amp;self) -&gt; Bool
    fn unwrap(self) -&gt; T
    fn unwrap_or(self, default: T) -&gt; T
    fn map&lt;U&gt;(self, f: fn(T) -&gt; U) -&gt; Result&lt;U, E&gt;
    fn map_err&lt;F&gt;(self, f: fn(E) -&gt; F) -&gt; Result&lt;T, F&gt;
    fn and_then&lt;U&gt;(self, f: fn(T) -&gt; Result&lt;U, E&gt;) -&gt; Result&lt;U, E&gt;
}</code></pre>
<h2 id="collections-module-stdcollections">Collections Module
(std::collections)</h2>
<h3 id="vec---dynamic-array">Vec<T> - Dynamic Array</h3>
<pre class="stark"><code>struct Vec&lt;T&gt; {
    ptr: *mut T,
    len: UInt64,
    cap: UInt64
}

impl&lt;T&gt; Vec&lt;T&gt; {
    fn new() -&gt; Vec&lt;T&gt;
    fn with_capacity(capacity: UInt64) -&gt; Vec&lt;T&gt;
    fn push(&amp;mut self, item: T)
    fn pop(&amp;mut self) -&gt; Option&lt;T&gt;
    fn len(&amp;self) -&gt; UInt64
    fn capacity(&amp;self) -&gt; UInt64
    fn is_empty(&amp;self) -&gt; Bool
    fn get(&amp;self, index: UInt64) -&gt; Option&lt;&amp;T&gt;
    fn get_mut(&amp;mut self, index: UInt64) -&gt; Option&lt;&amp;mut T&gt;
    fn insert(&amp;mut self, index: UInt64, item: T)
    fn remove(&amp;mut self, index: UInt64) -&gt; T
    fn clear(&amp;mut self)
    fn append(&amp;mut self, other: &amp;mut Vec&lt;T&gt;)
    fn extend(&amp;mut self, iter: impl Iterator&lt;Item = T&gt;)
}

// Index access
impl&lt;T&gt; Index&lt;UInt64&gt; for Vec&lt;T&gt; {
    type Output = T
    fn index(&amp;self, index: UInt64) -&gt; &amp;T
}

impl&lt;T&gt; IndexMut&lt;UInt64&gt; for Vec&lt;T&gt; {
    fn index_mut(&amp;mut self, index: UInt64) -&gt; &amp;mut T
}</code></pre>
<h3 id="hashmapk-v---hash-table">HashMap&lt;K, V&gt; - Hash Table</h3>
<pre class="stark"><code>struct HashMap&lt;K, V&gt; {
    // Internal implementation details
}

impl&lt;K: Hash + Eq, V&gt; HashMap&lt;K, V&gt; {
    fn new() -&gt; HashMap&lt;K, V&gt;
    fn with_capacity(capacity: UInt64) -&gt; HashMap&lt;K, V&gt;
    fn insert(&amp;mut self, key: K, value: V) -&gt; Option&lt;V&gt;
    fn get(&amp;self, key: &amp;K) -&gt; Option&lt;&amp;V&gt;
    fn get_mut(&amp;mut self, key: &amp;K) -&gt; Option&lt;&amp;mut V&gt;
    fn remove(&amp;mut self, key: &amp;K) -&gt; Option&lt;V&gt;
    fn contains_key(&amp;self, key: &amp;K) -&gt; Bool
    fn len(&amp;self) -&gt; UInt64
    fn is_empty(&amp;self) -&gt; Bool
    fn clear(&amp;mut self)
    fn keys(&amp;self) -&gt; KeysIter&lt;K&gt;
    fn values(&amp;self) -&gt; ValuesIter&lt;V&gt;
    fn iter(&amp;self) -&gt; Iter&lt;K, V&gt;
}</code></pre>
<h3 id="hashset---hash-set">HashSet<T> - Hash Set</h3>
<pre class="stark"><code>struct HashSet&lt;T&gt; {
    map: HashMap&lt;T, Unit&gt;
}

impl&lt;T: Hash + Eq&gt; HashSet&lt;T&gt; {
    fn new() -&gt; HashSet&lt;T&gt;
    fn insert(&amp;mut self, value: T) -&gt; Bool
    fn remove(&amp;mut self, value: &amp;T) -&gt; Bool
    fn contains(&amp;self, value: &amp;T) -&gt; Bool
    fn len(&amp;self) -&gt; UInt64
    fn is_empty(&amp;self) -&gt; Bool
    fn clear(&amp;mut self)
    fn iter(&amp;self) -&gt; Iter&lt;T&gt;
}</code></pre>
<h2 id="string-module-stdstring">String Module (std::string)</h2>
<h3 id="string-type-1">String Type</h3>
<pre class="stark"><code>struct String {
    bytes: Vec&lt;UInt8&gt;
}

impl String {
    fn new() -&gt; String
    fn with_capacity(capacity: UInt64) -&gt; String
    fn from(s: &amp;str) -&gt; String
    fn len(&amp;self) -&gt; UInt64
    fn is_empty(&amp;self) -&gt; Bool
    fn push(&amp;mut self, ch: Char)
    fn push_str(&amp;mut self, s: &amp;str)
    fn pop(&amp;mut self) -&gt; Option&lt;Char&gt;
    fn clear(&amp;mut self)
    fn chars(&amp;self) -&gt; CharsIter
    fn bytes(&amp;self) -&gt; &amp;[UInt8]
    fn as_str(&amp;self) -&gt; &amp;str
    fn into_bytes(self) -&gt; Vec&lt;UInt8&gt;
    fn substring(&amp;self, start: UInt64, end: UInt64) -&gt; &amp;str
    fn contains(&amp;self, pattern: &amp;str) -&gt; Bool
    fn starts_with(&amp;self, pattern: &amp;str) -&gt; Bool
    fn ends_with(&amp;self, pattern: &amp;str) -&gt; Bool
    fn find(&amp;self, pattern: &amp;str) -&gt; Option&lt;UInt64&gt;
    fn replace(&amp;self, from: &amp;str, to: &amp;str) -&gt; String
    fn split(&amp;self, delimiter: &amp;str) -&gt; SplitIter
    fn trim(&amp;self) -&gt; &amp;str
    fn to_lowercase(&amp;self) -&gt; String
    fn to_uppercase(&amp;self) -&gt; String
}

// String literals (&amp;str)
impl str {
    fn len(&amp;self) -&gt; UInt64
    fn is_empty(&amp;self) -&gt; Bool
    fn chars(&amp;self) -&gt; CharsIter
    fn bytes(&amp;self) -&gt; &amp;[UInt8]
    fn to_string(&amp;self) -&gt; String
    // ... similar methods to String
}</code></pre>
<h2 id="math-module-stdmath">Math Module (std::math)</h2>
<h3 id="basic-operations">Basic Operations</h3>
<pre class="stark"><code>// Constants
const PI: Float64 = 3.141592653589793
const E: Float64 = 2.718281828459045

// Basic functions
fn abs&lt;T: Num&gt;(x: T) -&gt; T
fn min&lt;T: Ord&gt;(a: T, b: T) -&gt; T
fn max&lt;T: Ord&gt;(a: T, b: T) -&gt; T
fn clamp&lt;T: Ord&gt;(value: T, min: T, max: T) -&gt; T

// Floating point functions
fn sqrt(x: Float64) -&gt; Float64
fn pow(base: Float64, exp: Float64) -&gt; Float64
fn log(x: Float64) -&gt; Float64
fn log10(x: Float64) -&gt; Float64
fn exp(x: Float64) -&gt; Float64

// Trigonometric functions
fn sin(x: Float64) -&gt; Float64
fn cos(x: Float64) -&gt; Float64
fn tan(x: Float64) -&gt; Float64
fn asin(x: Float64) -&gt; Float64
fn acos(x: Float64) -&gt; Float64
fn atan(x: Float64) -&gt; Float64
fn atan2(y: Float64, x: Float64) -&gt; Float64

// Rounding functions
fn floor(x: Float64) -&gt; Float64
fn ceil(x: Float64) -&gt; Float64
fn round(x: Float64) -&gt; Float64
fn trunc(x: Float64) -&gt; Float64

// Random numbers (simple linear congruential generator)
struct Random {
    seed: UInt64
}

impl Random {
    fn new(seed: UInt64) -&gt; Random
    fn next_int(&amp;mut self) -&gt; UInt64
    fn next_float(&amp;mut self) -&gt; Float64
    fn range(&amp;mut self, min: Int32, max: Int32) -&gt; Int32
}</code></pre>
<h2 id="io-module-stdio">IO Module (std::io)</h2>
<h3 id="basic-io-operations">Basic IO Operations</h3>
<pre class="stark"><code>// Standard streams
fn print(text: &amp;str)
fn println(text: &amp;str)
fn eprint(text: &amp;str)     // stderr
fn eprintln(text: &amp;str)   // stderr

// Simple file operations
struct File {
    handle: Int32
}

impl File {
    fn open(path: &amp;str) -&gt; Result&lt;File, IOError&gt;
    fn create(path: &amp;str) -&gt; Result&lt;File, IOError&gt;
    fn read_to_string(&amp;mut self) -&gt; Result&lt;String, IOError&gt;
    fn write(&amp;mut self, data: &amp;[UInt8]) -&gt; Result&lt;UInt64, IOError&gt;
    fn write_str(&amp;mut self, text: &amp;str) -&gt; Result&lt;UInt64, IOError&gt;
    fn close(self) -&gt; Result&lt;Unit, IOError&gt;
}

// Error types
enum IOError {
    NotFound,
    PermissionDenied,
    AlreadyExists,
    InvalidInput,
    Other(String)
}

// Utility functions
fn read_file(path: &amp;str) -&gt; Result&lt;String, IOError&gt;
fn write_file(path: &amp;str, content: &amp;str) -&gt; Result&lt;Unit, IOError&gt;</code></pre>
<h2 id="error-module-stderror">Error Module (std::error)</h2>
<h3 id="error-trait">Error Trait</h3>
<pre class="stark"><code>trait Error {
    fn message(&amp;self) -&gt; String
    fn source(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt;
}

// Standard error types
struct GenericError {
    message: String
}

impl Error for GenericError {
    fn message(&amp;self) -&gt; String {
        self.message.clone()
    }
    
    fn source(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; {
        None
    }
}</code></pre>
<h2 id="memory-module-stdmem">Memory Module (std::mem)</h2>
<h3 id="memory-utilities">Memory Utilities</h3>
<pre class="stark"><code>// Memory operations
fn size_of&lt;T&gt;() -&gt; UInt64
fn align_of&lt;T&gt;() -&gt; UInt64
fn swap&lt;T&gt;(a: &amp;mut T, b: &amp;mut T)
fn replace&lt;T&gt;(dest: &amp;mut T, src: T) -&gt; T
fn take&lt;T: Default&gt;(dest: &amp;mut T) -&gt; T

// Unsafe memory operations (future)
fn copy&lt;T&gt;(src: *const T, dst: *mut T, count: UInt64)
fn copy_nonoverlapping&lt;T&gt;(src: *const T, dst: *mut T, count: UInt64)</code></pre>
<h2 id="iterator-trait-stditer">Iterator Trait (std::iter)</h2>
<h3 id="basic-iterator-interface">Basic Iterator Interface</h3>
<pre class="stark"><code>trait Iterator {
    type Item
    
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;
    
    // Default implementations
    fn count(self) -&gt; UInt64
    fn collect&lt;C: FromIterator&lt;Self::Item&gt;&gt;(self) -&gt; C
    fn map&lt;U&gt;(self, f: fn(Self::Item) -&gt; U) -&gt; MapIter&lt;Self, U&gt;
    fn filter(self, predicate: fn(&amp;Self::Item) -&gt; Bool) -&gt; FilterIter&lt;Self&gt;
    fn fold&lt;B&gt;(self, init: B, f: fn(B, Self::Item) -&gt; B) -&gt; B
    fn reduce(self, f: fn(Self::Item, Self::Item) -&gt; Self::Item) -&gt; Option&lt;Self::Item&gt;
    fn any(self, predicate: fn(Self::Item) -&gt; Bool) -&gt; Bool
    fn all(self, predicate: fn(Self::Item) -&gt; Bool) -&gt; Bool
    fn find(self, predicate: fn(&amp;Self::Item) -&gt; Bool) -&gt; Option&lt;Self::Item&gt;
}

trait FromIterator&lt;T&gt; {
    fn from_iter&lt;I: Iterator&lt;Item = T&gt;&gt;(iter: I) -&gt; Self
}</code></pre>
<h2 id="conversion-traits">Conversion Traits</h2>
<h3 id="basic-conversion">Basic Conversion</h3>
<pre class="stark"><code>trait From&lt;T&gt; {
    fn from(value: T) -&gt; Self
}

trait Into&lt;T&gt; {
    fn into(self) -&gt; T
}

trait TryFrom&lt;T&gt; {
    type Error
    fn try_from(value: T) -&gt; Result&lt;Self, Self::Error&gt;
}

trait TryInto&lt;T&gt; {
    type Error
    fn try_into(self) -&gt; Result&lt;T, Self::Error&gt;
}

// String conversion
trait ToString {
    fn to_string(&amp;self) -&gt; String
}

trait FromStr {
    type Error
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Error&gt;
}</code></pre>
<h2 id="essential-trait-implementations">Essential Trait
Implementations</h2>
<h3 id="default-implementations">Default Implementations</h3>
<pre class="stark"><code>// Copy trait for basic types
impl Copy for Int8 { }
impl Copy for Int16 { }
impl Copy for Int32 { }
impl Copy for Int64 { }
impl Copy for UInt8 { }
impl Copy for UInt16 { }
impl Copy for UInt32 { }
impl Copy for UInt64 { }
impl Copy for Float32 { }
impl Copy for Float64 { }
impl Copy for Bool { }
impl Copy for Char { }
impl Copy for Unit { }

// Clone trait for all types
impl&lt;T: Copy&gt; Clone for T {
    fn clone(&amp;self) -&gt; T { *self }
}

// Eq trait for basic types
impl Eq for Int32 {
    fn eq(&amp;self, other: &amp;Int32) -&gt; Bool { *self == *other }
}
// ... similar for other types

// Ord trait for basic types
impl Ord for Int32 {
    fn cmp(&amp;self, other: &amp;Int32) -&gt; Ordering {
        if *self &lt; *other { Ordering::Less }
        else if *self &gt; *other { Ordering::Greater }
        else { Ordering::Equal }
    }
}</code></pre>
<h2 id="implementation-priorities">Implementation Priorities</h2>
<h3 id="phase-1-mvp">Phase 1 (MVP)</h3>
<ul>
<li>Basic types (primitives, String, Option, Result)</li>
<li>Vec<T> dynamic array</li>
<li>Basic IO (print, println, simple file operations)</li>
<li>Essential traits (Copy, Clone, Eq, Ord)</li>
</ul>
<h3 id="phase-2-enhanced">Phase 2 (Enhanced)</h3>
<ul>
<li>HashMap&lt;K, V&gt; and HashSet<T></li>
<li>Iterator trait and basic iterators</li>
<li>Math module with common functions</li>
<li>Enhanced string operations</li>
</ul>
<h3 id="phase-3-complete">Phase 3 (Complete)</h3>
<ul>
<li>Advanced memory utilities</li>
<li>Full IO system with buffering</li>
<li>Regular expressions</li>
<li>Time and date handling</li>
<li>Thread and concurrency primitives (future)</li>
</ul>
<h2 id="platform-considerations">Platform Considerations</h2>
<h3 id="cross-platform-abstractions">Cross-platform Abstractions</h3>
<ul>
<li>File path handling</li>
<li>Directory operations</li>
<li>Environment variables</li>
<li>Process spawning (future)</li>
</ul>
<h3 id="performance-notes">Performance Notes</h3>
<ul>
<li>Vec<T> uses exponential growth strategy</li>
<li>HashMap<T> uses open addressing with Robin Hood hashing</li>
<li>String operations are UTF-8 aware</li>
<li>Iterator chains compile to efficient loops</li>
</ul>
<h2 id="behavioral-requirements-core-v1">Behavioral Requirements (Core
v1)</h2>
<ul>
<li>Indexing <code>Vec&lt;T&gt;</code> with <code>[]</code> MUST perform
bounds checking and MUST trap on out-of-bounds access.</li>
<li><code>get</code>/<code>get_mut</code> MUST return <code>None</code>
for out-of-bounds indices and MUST NOT trap.</li>
<li><code>String::substring(start, end)</code> MUST validate UTF-8
boundaries and MUST trap on invalid boundaries or ranges.</li>
<li>IO functions MUST return <code>Result</code> with a
non-<code>Ok</code> variant on failure and MUST NOT silently ignore
errors. ## Conformance A conforming Core v1 implementation MUST follow
the requirements in this document. Any deviations or extensions MUST be
explicitly documented by the implementation.</li>
</ul>
<hr />
<h1 id="stark-modules-and-packages-specification">STARK Modules and
Packages Specification</h1>
<h2 id="overview-6">Overview</h2>
<p>This document defines the module system, visibility rules, and
package resolution for the STARK core language. It is normative for Core
v1.</p>
<h2 id="package-layout">Package Layout</h2>
<p>A package is a directory containing a <code>starkpkg.json</code>
manifest at its root.</p>
<ul>
<li>The manifest’s <code>entry</code> field defines the root source
file.</li>
<li>If <code>entry</code> is omitted, the default is
<code>src/main.stark</code>.</li>
</ul>
<p>All module paths are resolved relative to the package root unless
otherwise noted.</p>
<h2 id="module-declarations">Module Declarations</h2>
<p>Modules are declared with the <code>mod</code> keyword.</p>
<pre class="stark"><code>mod math;

mod inline {
    pub fn add(a: Int32, b: Int32) -&gt; Int32 { a + b }
}</code></pre>
<h3 id="file-based-modules">File-Based Modules</h3>
<p>A declaration <code>mod name;</code> loads one of the following
files, in order: 1. <code>name.stark</code> 2.
<code>name/mod.stark</code></p>
<p>The loaded file defines the contents of the module
<code>name</code>.</p>
<h2 id="module-paths">Module Paths</h2>
<p>Paths use <code>::</code> separators.</p>
<ul>
<li><code>crate</code> refers to the package root module.</li>
<li><code>self</code> refers to the current module.</li>
<li><code>super</code> refers to the parent module.</li>
</ul>
<p>Examples:</p>
<pre class="stark"><code>use crate::utils::math::add;
use super::config;</code></pre>
<h2 id="imports-use">Imports (<code>use</code>)</h2>
<p>The <code>use</code> statement brings names into scope.</p>
<pre class="stark"><code>use crate::utils::math::add;
use crate::utils::{math, io};
use crate::utils::math as m;
use crate::utils::*;</code></pre>
<p>Rules: - <code>use</code> affects name resolution in the current
module only. - <code>pub use</code> re-exports the imported name from
the current module. - Aliases with <code>as</code> are local to the
current module.</p>
<h2 id="visibility">Visibility</h2>
<ul>
<li>Items are private to their defining module by default.</li>
<li><code>pub</code> makes an item visible to parent modules and
external modules.</li>
<li><code>priv</code> explicitly marks an item as private (same as
default).</li>
</ul>
<p>Visibility applies to: - Functions, structs, enums, traits, impl
blocks, consts, type aliases, and modules.</p>
<h2 id="name-resolution-order-1">Name Resolution Order</h2>
<p>Within a module, names are resolved in the following order: 1. Local
scope 2. Items declared in the current module 3. Items brought into
scope by <code>use</code> 4. Items in parent modules via explicit
<code>super::</code> paths 5. Items in <code>crate</code> via explicit
<code>crate::</code> paths</p>
<p>Unqualified names do not implicitly search parent or crate
scopes.</p>
<h2 id="packages-and-dependencies">Packages and Dependencies</h2>
<p>Dependencies are declared in <code>starkpkg.json</code> under
<code>dependencies</code>.</p>
<p>Resolution order for external packages: 1. Local package source (the
current package) 2. Direct dependencies from <code>starkpkg.json</code>
3. Standard library package <code>std</code></p>
<p>Dependency modules are accessed via their package name:</p>
<pre class="stark"><code>use TensorLib::tensor::Tensor;</code></pre>
<h3 id="dependency-version-resolution-core-v1">Dependency Version
Resolution (Core v1)</h3>
<ul>
<li>Version strings follow semantic versioning.</li>
<li>If multiple versions satisfy a constraint, the highest version MUST
be selected.</li>
<li>If no version satisfies a constraint, compilation MUST fail with an
error.</li>
<li>The source of packages (registry, cache, or local path) is
implementation-defined, but the chosen version MUST be reported in build
output.</li>
</ul>
<h2 id="standard-library">Standard Library</h2>
<p>The standard library is available under the <code>std</code> package
name:</p>
<pre class="stark"><code>use std::io;
use std::collections::Vec;</code></pre>
<h2 id="cycles">Cycles</h2>
<p>Direct cyclic module dependencies are a compile-time error.</p>
<h2 id="errors">Errors</h2>
<ul>
<li>Importing an unknown module or item is a compile-time error.</li>
<li>Accessing a private item outside its module is a compile-time
error.</li>
<li>Ambiguous imports are a compile-time error unless aliased. ##
Conformance A conforming Core v1 implementation MUST follow the
requirements in this document. Any deviations or extensions MUST be
explicitly documented by the implementation.</li>
</ul>
<hr />
</body>
</html>
