# STARKLANG Package Manifest Format

> Non-Normative Note: This document provides architectural guidance and may evolve. The normative Core v1 language specification lives in `docs/spec/`.

This document defines the formal structure and specification of the STARKLANG package manifest file: `starkpkg.json`. It acts as the declarative configuration for a project or library, guiding compilation, dependency resolution, build output, execution behavior, and metadata definition.

---

## ğŸ“„ Manifest File: `starkpkg.json`
The package manifest must reside at the root of every STARKLANG package or project. It is automatically generated by `stark init`.

---

## ğŸ”– Basic Schema
```json
{
  "name": "project-name",
  "version": "1.0.0",
  "description": "Optional short description of the package",
  "entry": "src/main.stark",
  "execution_mode": "standalone",
  "authors": ["Your Name <email@example.com>"],
  "license": "MIT",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {},
  "build": {},
  "deploy": {},
  "exports": {}
}
```

---

## ğŸ” Field Descriptions

### ğŸ”¸ `name` *(required)*
Unique identifier of the package.
- Must use kebab-case.
- Example: `ml-pipeline-engine`

### ğŸ”¸ `version` *(required)*
Semantic version string.
- Follows `major.minor.patch` pattern.
- Example: `0.2.1`

### ğŸ”¸ `description`
Optional human-readable description of the package.

### ğŸ”¸ `entry`
Path to the primary entrypoint `.stark` file.
- Example: `src/main.stark`

### ğŸ”¸ `execution_mode`
Defines the expected runtime mode. Options:
- `standalone`
- `server`
- `serverless`
- `actor`
- `script`

### ğŸ”¸ `authors`
List of contributors in `"Name <email>"` format.

### ğŸ”¸ `license`
License identifier (e.g., `MIT`, `Apache-2.0`, `Proprietary`).

### ğŸ”¸ `dependencies`
Key-value map of required runtime packages:
```json
{
  "TensorLib": "^0.3.0",
  "CryptoLib": "~1.0.0"
}
```

### ğŸ”¸ `devDependencies`
Same format as `dependencies`, used for testing, tooling, etc.

### ğŸ”¸ `scripts`
Command hooks mapped to CLI actions:
```json
{
  "build": "stark build",
  "test": "stark test",
  "deploy": "stark deploy"
}
```

### ğŸ”¸ `build`
Custom build-time settings:
```json
{
  "outputDir": "build",
  "optimize": true,
  "bytecodeFormat": "standard"
}
```

### ğŸ”¸ `deploy`
Cloud deployment metadata:
```json
{
  "type": "aca",
  "region": "australia-east",
  "container": {
    "cpu": 1,
    "memory": "2Gi",
    "ingress": true
  }
}
```

### ğŸ”¸ `exports`
List of public symbols the package exposes:
```json
{
  "functions": ["calculate_tax", "predict"],
  "types": ["User", "Transaction"]
}
```

---

## ğŸ§© Future Extensions (Planned)
- `tests`: Inline test definitions with metadata.
- `format`: Style preferences for formatter/linter.
- `permissions`: Declare runtime permissions (filesystem, env access, network).
- `features`: Feature flags for conditional compilation.
- `profiles`: Different runtime profiles (`dev`, `prod`, `test`).

Example:
```json
{
  "profiles": {
    "dev": { "optimize": false },
    "prod": { "optimize": true, "telemetry": true }
  }
}
```

---

## ğŸ§  Integration Notes
- The compiler consumes `starkpkg.json` at build time to understand context.
- CLI overrides can temporarily replace manifest settings:
```bash
stark run --entry src/debug.stark --mode script
```

---

## âœ… Summary
The `starkpkg.json` format is the backbone of package resolution and build behavior in STARKLANG. It is designed to be clean, declarative, extensible, and compatible with future tooling such as package registries, dependency graphs, cloud deployers, and CI pipelines.

